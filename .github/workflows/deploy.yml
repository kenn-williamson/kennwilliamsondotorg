name: CD Pipeline - Deploy to Production

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on semantic version tags (v1.0.0, v2.1.3, etc.)

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}

jobs:
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version from tag
        id: version
        run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: backend
          file: backend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-backend:${{ steps.version.outputs.version }}
            ${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-backend:latest
          cache-from: |
            type=registry,ref=${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-backend:buildcache
            type=gha
          cache-to: |
            type=registry,ref=${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-backend:buildcache,mode=max
            type=gha,mode=max
          platforms: linux/amd64

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: frontend
          file: frontend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-frontend:${{ steps.version.outputs.version }}
            ${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-frontend:latest
          cache-from: |
            type=registry,ref=${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-frontend:buildcache
            type=gha
          cache-to: |
            type=registry,ref=${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-frontend:buildcache,mode=max
            type=gha,mode=max
          platforms: linux/amd64

      - name: Build and push migrations image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: migrations.Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-migrations:${{ steps.version.outputs.version }}
            ${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-migrations:latest
          cache-from: |
            type=registry,ref=${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-migrations:buildcache
            type=gha
          cache-to: |
            type=registry,ref=${{ env.IMAGE_PREFIX }}/kennwilliamsondotorg-migrations:buildcache,mode=max
            type=gha,mode=max
          platforms: linux/amd64

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    environment:
      name: production
      url: https://kennwilliamson.org

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get runner IP address
        id: ip
        run: echo "ipv4=$(curl -s https://api.ipify.org)" >> $GITHUB_OUTPUT

      - name: Whitelist runner IP in security group
        run: |
          aws ec2 authorize-security-group-ingress \
            --group-id ${{ secrets.EC2_SECURITY_GROUP_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32 \
            --tag-specifications 'ResourceType=security-group-rule,Tags=[{Key=Name,Value=github-actions-temp},{Key=ManagedBy,Value=GitHubActions}]' \
            || echo "âš ï¸ Rule may already exist, continuing..."

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy application
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            cd /opt/kennwilliamson/kennwilliamsondotorg

            # Fetch latest tags from GitHub
            echo "ðŸ“¥ Fetching latest tags..."
            git fetch --tags

            # Checkout the version to deploy (force to handle any local changes)
            echo "ðŸ”„ Checking out version ${{ needs.build-and-push.outputs.version }}..."
            git checkout -f ${{ needs.build-and-push.outputs.version }}

            # Set version to deploy
            export VERSION=${{ needs.build-and-push.outputs.version }}
            export GITHUB_USER=${{ github.repository_owner }}

            # Make deploy script executable
            chmod +x scripts/deploy-from-registry.sh

            # Run deployment
            echo "ðŸš€ Running deployment script..."
            ./scripts/deploy-from-registry.sh
          EOF

      - name: Verify deployment health
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            cd /opt/kennwilliamson/kennwilliamsondotorg

            # Wait for services to be healthy
            echo "â³ Waiting for services to stabilize..."
            sleep 30

            # Check service health
            docker-compose -f docker-compose.production.yml --env-file .env.production ps

            # Check backend health endpoint
            if docker-compose -f docker-compose.production.yml --env-file .env.production exec -T backend wget -q --spider http://localhost:8080/backend/public/health; then
              echo "âœ… Backend health check passed"
            else
              echo "âŒ Backend health check failed"
              exit 1
            fi

            # Check frontend health endpoint
            if docker-compose -f docker-compose.production.yml --env-file .env.production exec -T frontend wget -q --spider http://localhost:3000/api/health; then
              echo "âœ… Frontend health check passed"
            else
              echo "âŒ Frontend health check failed"
              exit 1
            fi

            echo "ðŸŽ‰ Deployment verification successful!"
          EOF

      - name: Rollback on failure
        if: failure()
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            cd /opt/kennwilliamson/kennwilliamsondotorg
            echo "âŒ Deployment failed, checking for previous version..."

            # Get the previous tag for rollback
            PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed -n '2p')

            if [ -n "$PREVIOUS_TAG" ]; then
              echo "ðŸ”„ Rolling back to $PREVIOUS_TAG..."
              git checkout -f "$PREVIOUS_TAG"
              export VERSION="$PREVIOUS_TAG"
              export GITHUB_USER=${{ github.repository_owner }}

              # Pull images for previous version
              docker-compose -f docker-compose.production.yml --env-file .env.production pull

              # Stop and restart with previous version (skip migrations - see note below)
              docker-compose -f docker-compose.production.yml --env-file .env.production down --timeout 30
              docker-compose -f docker-compose.production.yml --env-file .env.production up -d

              # Wait for services
              sleep 30
              docker-compose -f docker-compose.production.yml --env-file .env.production ps

              echo ""
              echo "âš ï¸  DATABASE MIGRATION NOTICE:"
              echo "   Migrations were NOT automatically reverted. Manual intervention may be required."
              echo "   SSH into the server and run: docker-compose -f docker-compose.production.yml --env-file .env.production run --rm migrations migrate revert"
              echo ""

              echo "âœ… Code rolled back to $PREVIOUS_TAG"
            else
              echo "âš ï¸ No previous version found for rollback, manual intervention required"
            fi
          EOF

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key

      - name: Remove runner IP from security group
        if: always()
        run: |
          aws ec2 revoke-security-group-ingress \
            --group-id ${{ secrets.EC2_SECURITY_GROUP_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32 \
            || echo "âš ï¸ Rule may already be removed, continuing..."

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy]
    if: always()

    steps:
      - name: Deployment Success
        if: needs.deploy.result == 'success'
        run: |
          echo "ðŸŽ‰ Deployment of ${{ needs.build-and-push.outputs.version }} to production succeeded!"
          echo "ðŸŒ Application is live at https://kennwilliamson.org"

      - name: Deployment Failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "âŒ Deployment of ${{ needs.build-and-push.outputs.version }} to production failed!"
          echo "ðŸ” Check the deployment logs for details"
          exit 1
