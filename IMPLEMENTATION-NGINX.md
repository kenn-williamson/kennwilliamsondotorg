# Nginx Implementation

## Overview
Nginx reverse proxy architecture and configuration decisions.

## Architecture Decisions

### Why Nginx
**Decision**: Use Nginx as reverse proxy

**Why:**
- Industry standard
- High performance
- SSL termination
- Static file serving
- Load balancing ready
- Mature and reliable

**Alternatives considered:**
- **Caddy**: Automatic SSL but less control
- **Traefik**: Overkill for single server
- **Direct access**: No SSL termination, no static files

### Reverse Proxy Pattern
**Decision**: Nginx sits in front of all services

**Flow:**
```
Browser → Nginx (443) → Frontend (3000) or Backend (8080)
```

**Why:**
- Single entry point
- SSL termination in one place
- Static file caching
- Request routing logic
- Security headers

**Trade-offs:**
- Additional layer (minimal overhead)
- Worth it: Flexibility and security

### Hybrid API Routing
**Decision**: Two API paths with different purposes

**Routes:**
- `/api/*` → Frontend (SSR proxy to backend)
- `/backend/*` → Backend (direct access)

**Why:**
- SSR needs cookie-based session
- Client needs JWT-based direct access
- Each optimized for use case

**See**: [ARCHITECTURE.md](ARCHITECTURE.md#hybrid-api-architecture) for details

## Configuration Strategy

### Environment-Specific Configs
**Decision**: Separate nginx configs per environment

**Configs:**
- Development: Hot reload support, verbose logging
- Local production: Production-like for testing
- Production: Optimized, minimal logging

**Why:**
- Different needs per environment
- Development needs HMR WebSocket
- Production needs performance
- Local-prod tests production config

### SSL Certificate Management
**Decision**: Runtime certificate generation

**Why:**
- Certificates not in git
- Generated by scripts
- Environment-specific

**Certificates:**
- Development: Self-signed via `generate-ssl.sh`
- Production: Let's Encrypt via `ssl-manager.sh`

### Static File Serving
**Decision**: Nginx serves static files directly

**Why:**
- Faster than app server
- Reduces backend load
- Built-in caching
- Compression support

**Files served:**
- Frontend build assets (`/_nuxt/*`)
- Public directory files
- Robots.txt, sitemap.xml

## Security Decisions

### HTTPS Enforcement
**Decision**: Redirect all HTTP to HTTPS

**Why:**
- Security best practice
- Prevents downgrade attacks
- Required for modern APIs

### Security Headers
**Headers added:**
- HSTS: Force HTTPS
- X-Frame-Options: Prevent clickjacking
- X-Content-Type-Options: Prevent MIME sniffing
- X-XSS-Protection: Browser XSS protection
- Referrer-Policy: Control referer leakage

**Why:**
- Defense in depth
- Minimal performance cost
- Industry best practices

**See**: [IMPLEMENTATION-SECURITY.md](IMPLEMENTATION-SECURITY.md#infrastructure-security) for details

### Rate Limiting
**Status**: Currently disabled

**Decision**: Disabled due to Docker shared memory issues

**Why disabled:**
- Docker shared memory allocation complex
- Backend rate limiting active
- Will re-enable when fixed

**Future:**
- Fix shared memory configuration
- Re-enable nginx rate limiting
- Defense in depth

## Performance Decisions

### Caching Strategy
**Decision**: Cache static assets aggressively

**Why:**
- Reduce backend load
- Faster page loads
- Lower bandwidth

**Configuration:**
- Long cache for versioned assets
- No cache for HTML
- Conditional caching for API

### Compression
**Decision**: gzip compression for text content

**Why:**
- Smaller transfer size
- Faster page loads
- Minimal CPU cost

**What's compressed:**
- HTML, CSS, JavaScript
- JSON API responses
- SVG images

### Connection Handling
**Decision**: Keep-alive connections

**Why:**
- Reduce connection overhead
- Better performance
- Lower latency

## Docker Integration

### Docker DNS Resolution
**Decision**: Use Docker's internal DNS

**Why:**
- Services find each other by name
- No hardcoded IPs
- Works across environments

**Implementation:**
- Variable-based upstream configuration
- Prevents startup failures
- Resolves at request time

### Service Discovery
**Pattern**: Nginx resolves service names via Docker DNS

**Why:**
- Services can restart with different IPs
- No configuration updates needed
- Automatic failover ready

## Development Features

### Hot Module Replacement
**Decision**: WebSocket passthrough for HMR

**Why:**
- Instant updates during development
- Better developer experience
- Required for Vite/Nuxt HMR

**Configuration:**
- WebSocket upgrade headers
- No buffering for dev
- Proper timeouts

### Verbose Logging
**Decision**: More logging in development

**Why:**
- Debugging easier
- See all requests
- Understand routing

**Production:**
- Minimal logging
- Focus on errors
- Performance over verbosity

## Future Enhancements

**When to add:**
- **Load balancing**: Multiple backend instances
- **Caching layer**: Redis-based cache
- **WAF rules**: Advanced security
- **Rate limiting**: Fix shared memory issue

**Current approach sufficient for:**
- Single-instance deployment
- Development workflow
- Basic security needs
- Static file optimization
