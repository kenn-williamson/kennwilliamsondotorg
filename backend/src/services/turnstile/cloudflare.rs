use anyhow::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

use super::trait_def::TurnstileServiceTrait;

/// Production implementation of TurnstileService that verifies tokens with Cloudflare API
///
/// This service makes HTTP requests to Cloudflare's Turnstile verification endpoint
/// to validate tokens generated by the Turnstile widget on the frontend.
///
/// # Example
/// ```rust
/// let service = CloudflareTurnstileService::new("your_secret_key".to_string());
/// let is_valid = service.verify_token("token_from_frontend", "192.168.1.1").await?;
/// ```
pub struct CloudflareTurnstileService {
    secret_key: String,
    http_client: reqwest::Client,
}

impl CloudflareTurnstileService {
    /// Create a new Cloudflare Turnstile verification service
    ///
    /// # Arguments
    /// * `secret_key` - The secret key from Cloudflare Turnstile dashboard
    ///
    /// # Note
    /// For testing, use Cloudflare's test secret key: `1x0000000000000000000000000000000AA`
    /// This key always returns success and doesn't require real verification.
    pub fn new(secret_key: String) -> Self {
        Self {
            secret_key,
            http_client: reqwest::Client::new(),
        }
    }

    /// Load service from environment variable
    ///
    /// Reads `TURNSTILE_SECRET_KEY` from environment.
    ///
    /// # Returns
    /// * `Some(service)` if TURNSTILE_SECRET_KEY is set
    /// * `None` if environment variable is not set
    pub fn from_env() -> Option<Self> {
        std::env::var("TURNSTILE_SECRET_KEY")
            .ok()
            .map(Self::new)
    }
}

#[async_trait]
impl TurnstileServiceTrait for CloudflareTurnstileService {
    async fn verify_token(&self, token: &str, ip_address: &str) -> Result<bool> {
        let request_body = TurnstileVerificationRequest {
            secret: &self.secret_key,
            response: token,
            remoteip: Some(ip_address),
        };

        log::debug!(
            "Verifying Turnstile token for IP: {} (token length: {})",
            ip_address,
            token.len()
        );

        let response = self
            .http_client
            .post("https://challenges.cloudflare.com/turnstile/v0/siteverify")
            .json(&request_body)
            .send()
            .await
            .map_err(|e| {
                log::error!("Turnstile API request failed: {}", e);
                anyhow::anyhow!("Failed to connect to Cloudflare API: {}", e)
            })?;

        let verification: TurnstileVerificationResponse = response.json().await.map_err(|e| {
            log::error!("Failed to parse Turnstile API response: {}", e);
            anyhow::anyhow!("Invalid response from Cloudflare API: {}", e)
        })?;

        // Log verification result
        if verification.success {
            log::debug!("Turnstile verification succeeded for IP: {}", ip_address);
        } else {
            log::warn!(
                "Turnstile verification failed for IP: {}, error codes: {:?}",
                ip_address,
                verification.error_codes
            );
        }

        Ok(verification.success)
    }
}

/// Request body for Cloudflare Turnstile verification API
#[derive(Debug, Serialize)]
struct TurnstileVerificationRequest<'a> {
    /// The secret key from Cloudflare dashboard
    secret: &'a str,
    /// The token to verify
    response: &'a str,
    /// Optional: The user's IP address
    #[serde(skip_serializing_if = "Option::is_none")]
    remoteip: Option<&'a str>,
}

/// Response from Cloudflare Turnstile verification API
#[derive(Debug, Deserialize)]
struct TurnstileVerificationResponse {
    /// Whether the token is valid
    success: bool,
    /// Error codes if verification failed
    /// Common codes: "missing-input-secret", "invalid-input-secret",
    /// "missing-input-response", "invalid-input-response", "timeout-or-duplicate"
    #[serde(rename = "error-codes")]
    error_codes: Option<Vec<String>>,
    /// Timestamp of when the challenge was solved
    #[serde(rename = "challenge_ts")]
    _challenge_ts: Option<String>,
    /// Hostname where the challenge was solved
    _hostname: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_service_creation() {
        let service = CloudflareTurnstileService::new("test_secret".to_string());
        assert_eq!(service.secret_key, "test_secret");
    }

    // Note: from_env() tests are omitted because env var manipulation
    // is unreliable in parallel test execution. The from_env() method
    // is simple enough (just calls std::env::var) that we can trust it works.

    // Integration test with Cloudflare test key
    // This uses the real Cloudflare API with their test secret key
    // which always returns success
    #[tokio::test]
    #[ignore] // Ignore by default to avoid hitting external API in unit tests
    async fn test_verify_with_cloudflare_test_key() {
        // Cloudflare's test secret key (always passes)
        let service = CloudflareTurnstileService::new(
            "1x0000000000000000000000000000000AA".to_string()
        );

        // Any token works with the test key
        let result = service
            .verify_token("test_token", "192.168.1.1")
            .await;

        assert!(result.is_ok());
        assert!(result.unwrap());
    }
}
