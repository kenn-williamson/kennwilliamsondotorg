use actix_web::{test, web, App, HttpResponse, Result};
use serde_json::{json, Value};
use backend::models::user::{CreateUserRequest, LoginRequest};
use backend::models::incident_timer::CreateIncidentTimerRequest;
use backend::{services, routes, middleware};
use sqlx::PgPool;

// Health endpoint functions for testing
async fn health() -> Result<HttpResponse> {
    Ok(HttpResponse::Ok().json(serde_json::json!({
        "status": "healthy",
        "service": "kennwilliamson-backend",
        "version": "0.1.0"
    })))
}

async fn health_db(pool: web::Data<PgPool>) -> Result<HttpResponse> {
    match sqlx::query("SELECT 1").fetch_one(pool.get_ref()).await {
        Ok(_) => Ok(HttpResponse::Ok().json(serde_json::json!({
            "status": "healthy",
            "database": "connected",
            "service": "kennwilliamson-backend",
            "version": "0.1.0"
        }))),
        Err(e) => Ok(HttpResponse::ServiceUnavailable().json(serde_json::json!({
            "status": "unhealthy",
            "database": "disconnected",
            "error": e.to_string()
        })))
    }
}

// Test helper to create test app
async fn create_test_app() -> impl actix_web::dev::Service<
    actix_web::dev::ServiceRequest,
    Response = actix_web::dev::ServiceResponse,
    Error = actix_web::Error,
> {
    // Initialize environment and database
    dotenv::dotenv().ok();
    env_logger::try_init().ok();
    
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set for tests");
    
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to connect to test database");
        
    // Run migrations
    sqlx::migrate!("./migrations")
        .run(&pool)
        .await
        .expect("Failed to run migrations");
    
    // Create services (use a test JWT secret)
    let jwt_secret = std::env::var("JWT_SECRET")
        .unwrap_or_else(|_| "test-secret-key".to_string());
    
    let auth_service = services::auth::AuthService::new(pool.clone(), jwt_secret);
    let incident_timer_service = services::incident_timer::IncidentTimerService::new(pool.clone());
    
    test::init_service(
        App::new()
            .app_data(web::Data::new(pool.clone()))
            .app_data(web::Data::new(auth_service.clone()))
            .app_data(web::Data::new(incident_timer_service.clone()))
            .route("/health", web::get().to(health))
            .route("/health/db", web::get().to(health_db))
            .service(
                web::scope("/auth")
                    .configure(routes::auth::configure_routes)
            )
            .service(
                web::scope("/api")
                    .configure(routes::incident_timers::configure_public_routes)
                    .service(
                        web::scope("")
                            .wrap(actix_web::middleware::from_fn(middleware::auth::jwt_auth_middleware))
                            .configure(routes::incident_timers::configure_protected_routes)
                    )
            )
    ).await
}

// Test helper to extract JWT token from response
fn extract_token(response_body: &str) -> String {
    let json: Value = serde_json::from_str(response_body).expect("Invalid JSON");
    json["token"].as_str().expect("Token not found").to_string()
}

#[actix_web::test]
async fn test_health_endpoints() {
    let mut app = create_test_app().await;
    
    // Test basic health check
    let req = test::TestRequest::get().uri("/health").to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    // Test database health check
    let req = test::TestRequest::get().uri("/health/db").to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
}

#[actix_web::test]
async fn test_user_registration_and_login() {
    let mut app = create_test_app().await;
    
    // Test user registration
    let register_data = CreateUserRequest {
        email: "test@example.com".to_string(),
        password: "password123".to_string(),
        first_name: "Test".to_string(),
        last_name: "User".to_string(),
        user_slug: "testuser".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/auth/register")
        .set_json(&register_data)
        .to_request();
        
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let json: Value = serde_json::from_str(body_str).unwrap();
    
    // Verify registration response contains token and user info
    assert!(json["token"].is_string());
    assert_eq!(json["user"]["email"], "test@example.com");
    assert_eq!(json["user"]["user_slug"], "testuser");
    
    // Test user login
    let login_data = LoginRequest {
        email: "test@example.com".to_string(),
        password: "password123".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/auth/login")
        .set_json(&login_data)
        .to_request();
        
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let json: Value = serde_json::from_str(body_str).unwrap();
    
    // Verify login response contains token and user info
    assert!(json["token"].is_string());
    assert_eq!(json["user"]["email"], "test@example.com");
    assert_eq!(json["user"]["user_slug"], "testuser");
}

#[actix_web::test]
async fn test_authentication_failures() {
    let mut app = create_test_app().await;
    
    // Test registration with duplicate email
    let register_data = CreateUserRequest {
        email: "duplicate@example.com".to_string(),
        password: "password123".to_string(),
        first_name: "First".to_string(),
        last_name: "User".to_string(),
        user_slug: "firstuser".to_string(),
    };
    
    // First registration should succeed
    let req = test::TestRequest::post()
        .uri("/auth/register")
        .set_json(&register_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    // Second registration with same email should fail
    let register_data_duplicate = CreateUserRequest {
        email: "duplicate@example.com".to_string(),
        password: "password123".to_string(),
        first_name: "Second".to_string(),
        last_name: "User".to_string(),
        user_slug: "seconduser".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/auth/register")
        .set_json(&register_data_duplicate)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error());
    
    // Test login with wrong password
    let login_data = LoginRequest {
        email: "duplicate@example.com".to_string(),
        password: "wrongpassword".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/auth/login")
        .set_json(&login_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error());
    
    // Test login with non-existent user
    let login_data = LoginRequest {
        email: "nonexistent@example.com".to_string(),
        password: "password123".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/auth/login")
        .set_json(&login_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error());
}

#[actix_web::test]
async fn test_protected_routes_require_auth() {
    let mut app = create_test_app().await;
    
    // Test that protected endpoints reject requests without JWT
    let protected_endpoints = vec![
        ("POST", "/api/incident-timers"),
        ("GET", "/api/incident-timers"),
        ("PUT", "/api/incident-timers/123"),
        ("DELETE", "/api/incident-timers/123"),
    ];
    
    for (method, endpoint) in protected_endpoints {
        let req = match method {
            "POST" => test::TestRequest::post().uri(endpoint).to_request(),
            "GET" => test::TestRequest::get().uri(endpoint).to_request(),
            "PUT" => test::TestRequest::put().uri(endpoint).to_request(),
            "DELETE" => test::TestRequest::delete().uri(endpoint).to_request(),
            _ => unreachable!(),
        };
        
        let resp = test::call_service(&mut app, req).await;
        assert!(resp.status().is_client_error()); // Should return 401 Unauthorized
    }
}

#[actix_web::test]
async fn test_incident_timer_crud_operations() {
    let mut app = create_test_app().await;
    
    // First, register and login a user to get JWT token
    let register_data = CreateUserRequest {
        email: "timer_test@example.com".to_string(),
        password: "password123".to_string(),
        first_name: "Timer".to_string(),
        last_name: "Tester".to_string(),
        user_slug: "timertester".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/auth/register")
        .set_json(&register_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let token = extract_token(body_str);
    
    // Test creating incident timer
    let create_timer_data = CreateIncidentTimerRequest {
        notes: Some("Test incident timer creation".to_string()),
    };
    
    let req = test::TestRequest::post()
        .uri("/api/incident-timers")
        .insert_header(("Authorization", format!("Bearer {}", token)))
        .set_json(&create_timer_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let json: Value = serde_json::from_str(body_str).unwrap();
    let timer_id = json["id"].as_str().expect("Timer ID not found");
    
    // Test listing incident timers for user
    let req = test::TestRequest::get()
        .uri("/api/incident-timers")
        .insert_header(("Authorization", format!("Bearer {}", token)))
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let json: Value = serde_json::from_str(body_str).unwrap();
    assert!(json.is_array());
    assert!(json.as_array().unwrap().len() > 0);
    
    // Test updating incident timer
    let update_data = json!({
        "notes": "Updated incident timer notes"
    });
    
    let req = test::TestRequest::put()
        .uri(&format!("/api/incident-timers/{}", timer_id))
        .insert_header(("Authorization", format!("Bearer {}", token)))
        .set_json(&update_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let json: Value = serde_json::from_str(body_str).unwrap();
    assert_eq!(json["notes"], "Updated incident timer notes");
    
    // Test deleting incident timer
    let req = test::TestRequest::delete()
        .uri(&format!("/api/incident-timers/{}", timer_id))
        .insert_header(("Authorization", format!("Bearer {}", token)))
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    // Verify timer is deleted by trying to update it again
    let req = test::TestRequest::put()
        .uri(&format!("/api/incident-timers/{}", timer_id))
        .insert_header(("Authorization", format!("Bearer {}", token)))
        .set_json(&update_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error()); // Should return 404 Not Found
}

#[actix_web::test]
async fn test_public_incident_timer_endpoint() {
    let mut app = create_test_app().await;
    
    // Register a user and create an incident timer
    let register_data = CreateUserRequest {
        email: "public_test@example.com".to_string(),
        password: "password123".to_string(),
        first_name: "Public".to_string(),
        last_name: "Tester".to_string(),
        user_slug: "publictester".to_string(),
    };
    
    let req = test::TestRequest::post()
        .uri("/auth/register")
        .set_json(&register_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let token = extract_token(body_str);
    
    // Create an incident timer
    let create_timer_data = CreateIncidentTimerRequest {
        notes: Some("Public test timer".to_string()),
    };
    
    let req = test::TestRequest::post()
        .uri("/api/incident-timers")
        .insert_header(("Authorization", format!("Bearer {}", token)))
        .set_json(&create_timer_data)
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    // Test public endpoint access without authentication
    let req = test::TestRequest::get()
        .uri("/api/incident-timers/publictester")
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_success());
    
    let body = test::read_body(resp).await;
    let body_str = std::str::from_utf8(&body).unwrap();
    let json: Value = serde_json::from_str(body_str).unwrap();
    assert_eq!(json["notes"], "Public test timer");
    
    // Test public endpoint with non-existent user slug
    let req = test::TestRequest::get()
        .uri("/api/incident-timers/nonexistentuser")
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error()); // Should return 404 Not Found
}

#[actix_web::test]
async fn test_jwt_token_validation() {
    let mut app = create_test_app().await;
    
    // Test with invalid JWT token
    let req = test::TestRequest::post()
        .uri("/api/incident-timers")
        .insert_header(("Authorization", "Bearer invalid_token"))
        .set_json(&json!({"notes": "Should fail"}))
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error()); // Should return 401 Unauthorized
    
    // Test with malformed Authorization header
    let req = test::TestRequest::post()
        .uri("/api/incident-timers")
        .insert_header(("Authorization", "InvalidFormat"))
        .set_json(&json!({"notes": "Should fail"}))
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error()); // Should return 401 Unauthorized
    
    // Test with missing Authorization header (already covered in other tests)
    let req = test::TestRequest::post()
        .uri("/api/incident-timers")
        .set_json(&json!({"notes": "Should fail"}))
        .to_request();
    let resp = test::call_service(&mut app, req).await;
    assert!(resp.status().is_client_error()); // Should return 401 Unauthorized
}